
## 如何区分FP,TP,FN,TN
拿`FP`来讲,第二个字母是分类器给出的分类结果,第一个字母根据groud_truth对分类器评价其分对了还是分错了. 
>真实label就可以根据正负号性质来判断,负负得正,正负得负这样来记忆.

**FP:**分类器判为正样本,但实际上分类器分错了,也就说这个样本为负  
**TP:**分类器判为正样本,实际上分类器也是正确的,也就是说这个样本为负  

**FN:**分类器判为负样本,实际上分错了,真实样本为正  
**TN:**分类器判为负样本,实际上分对了,真实样本为负  

## 准确率(Precision)和召回率(Recall)
准确率:检测结果中多少是对的  
比如你去买橘子,挑了20个**你认为是不错的**,回去拨开发现其中有8个都烂掉了(FP),剩余的12个是好的(TP).准确率就是12/20  
$$P=\frac{TP}{TP+FP}$$
召回率:真实目标中有多少被检测出来了
$$R=\frac{TP}{TP+FN}$$

##  何为ap?
我们需要对Precision和Recall做一个整体的评估，而这个评估就是AP（Average Precision），其定义非常简单，  
$$AP=\int PdR$$
其实得到的(P,R)点都是离散的,即求连线下围成的面积
一组结果dets可以根据IOU阈值与gts求出一组(P,R),如何求多组PR对呢?对排序好的dets结果进行“截取”，依次取dets结果的前1个（也就是只有第一个结果）、前2个、...、前N个，每次都能够得到一个对应的P和R数值，随着观察数量的增大，R一定会变大或不变。因此可以以R为横轴，P为纵轴，将每次的“截取”观察到的P和R画成一个点(R，P),然后求连线下的面积  
>值得注意的是，当“截取”到的新结果为FP时，因为R没有变化所以并不会有新的（R，P）点诞生。最后利用这些（R，P）点绘制成P-R曲线  

下面是给定了根据预测bbox结果dets,gts和iou阈值求


```python
def get_TP_FP_FN(dets, gts, iou_thre):
    #dets=TP+FP
    dets.sort()
    TPs = []
    for dt in dets:
        max_iou = max([iou(dt, gt) for gt in gts])
        max_iou_gt = argmax([iou(dt, gt) for gt in gts])
        if max_iou >= iou_thre:
            TPs.append(dt)#IOU大于阈值的认为是TP
            gts.pop(max_iou_gt)#移除掉已经匹配的box,作为FN
        FPs = [dt for dt in dets if not dt in TPs]#分类器认为是正样本,但没有gt与之匹配,即为FP
        FNs = gts#剩下的groud_true中,无人认领的(被分类器判为N的真实样本)即为FN
    P = len(TPs) / len(TPs) + len(FPs)
    R = len(TPs) / len(TPs) + len(FNs)
    return (P, R)
```

## mmap从何而来?
首先是位置偏差问题。有的使用场景对位置的准确度要求不高，有的则要求精确定位。因此，mmAP先按位置准确度的需求进行划分，设置一组IOU阈值，这组阈值为 (0.5, 0.55, 0.6, ..., 0.9, 0.95),如果DT与GT的IOU超过阈值，则视作检测成功。这样每给定一个阈值就可以计算出一个性能（也就是mAP，后面详述），然后对这些性能取平均（也就是mmAP）就是整个检测算法的性能了。然后是类别平衡问题，这一问题在分类领域非常常见，“将一个白血病患者错分为健康的人“和“将一个健康的人错分为白血病患者“是一样的吗？显然不是，因为白血病患者本身就属于少数，如果一个分类器把所有人都无脑地判断为健康，其正确率就是 健康的人/全部人。这个分类器的正确率很高但是完全失去了判断病患的功能。mmAP为了公平的评价检测器在各个类别上的性能，采用了类别间求平均的方法：先给定一个IOU阈值，然后将所有的GT和DT按照类别先进行划分，用同一类的所有GT和DT计算出一个性能（也就是AP，马上详述），然后对所有类别的性能取平均（mAP），就是检测算法在这个IOU阈值下的性能。  
给定一个阈值比如说IOU@0.5,所有类别ap的平均就是在IOU@0.5下的map@0.5
